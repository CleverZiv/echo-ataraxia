---
title: Spring AOP系列（二）— 动态代理
tags:
  - aop
categories:
  - 总结
date: 2021-07-16 00:00:00
---

接上一篇[Spring AOP系列（一）— 代理模式](https://juejin.cn/post/6985004955149008904)，本篇来聊聊动态代理。
## 动态代理与静态代理的区别
要想了解动态代理与静态代理的区别，需要有两个前置知识点：java程序是如何执行的以及类加载机制。

<!-- more -->

### java程序执行过程
![java程序执行过程](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/467e3fcce6be49f2ad62790ba273499e~tplv-k3u1fbpfcp-zoom-1.image)
1. 将java源码(.java文件)通过编译器(javac.exe)编译成JVM文件(.class文件)。
2. 将JVM文件通过java.exe执行，输出结果。
   静态代理显示的编写了代理类，因此编译过程中会生成对应的.class文件，最终在运行过程中执行这些.class文件。而动态代理并未显示编写代理类，也并不存在代理类的.class文件，而是在程序运行期间由JVM根据反射等机制动态的生成。
### 类加载机制
java虚拟机中类加载的全过程，分别是：加载、验证、准备、解析、初始化。其中“加载”是类加载的第一个步骤，在加载阶段，虚拟机需要完成以下3件事情：
1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的 `java.lang.class`对象，作为方法区这个类的各种数据访问入口。
   由于虚拟机规范对这3点要求并不具体，所以实际的实现是非常灵活的。关于第1点，获取类的二进制字节流（class字节码）就有很多途径：
- 从ZIP包获取，这是JAR、EAR、WAR等格式的基础。
- 从网络中获取，典型的应用是 Applet。
- 运行时计算生成，这种场景使用最多的是动态代理技术，在 `java.lang.reflect.Proxy`类中，就是用了 `ProxyGenerator.generateProxyClass`来为特定接口生成形式为 `*$Proxy` 的代理类的二进制字节流。
- 由其它文件生成，典型应用是JSP，即由JSP文件生成对应的Class类。
- 从数据库中获取等等。

其中“运行时计算生成”，就是“动态代理”技术的实现思路。
### 小结
**静态代理的优点**
实现简单，且不侵入原代码。
**静态代理的缺点**
1. 静态代理要求：代理对象与被代理对象需要实现一致的接口，因此当希望使用一个代理类代理多个被代理类时，可以通过以下两种方式：
- 只维护一个代理类，由这个代理类实现多个接口，但是这样就导致代理类过于庞大。
- 新建多个代理类，每个目标对象对应一个代理类，但是这样会产生过多的代理类。
2. 当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，不易维护。
   动态代理的优势不在于省去了编写代理类的工作量，而是实现了可以在原始类和接口还未知的时候，就确定代理类的代理行为。当代理类与原始类脱离直接联系后，就可以很灵活地重用于不同的应用场景之中。

接下来将详细地介绍动态代理的两种常见的实现方式：常见的动态代理的实现方式有两种：**JDK动态代理和CGLIB动态代理**

**最后**
- 文章若有错误，欢迎评论留言指出，也欢迎转载，转载请注明出处；